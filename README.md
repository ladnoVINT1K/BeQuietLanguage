# BeQuite

## Содержание
- [Введение](#введение)
  - [Назначение транслятора BeQuite](#назначение-транслятора-bequite)
- [Архитектура транслятора](#архитектура-транслятора)
  - [Лексический анализатор (Lexer)](#лексический-анализатор-lexer)
  - [Синтаксический анализатор (Syntaxer)](#синтаксический-анализатор-syntaxer)
  - [Семантический анализатор](#семантический-анализатор)
  - [Промежуточное представление (POLIZ)](#промежуточное-представление-poliz)
  - [Интерпретатор](#интерпретатор)
- [Грамматика языка BeQuite](#грамматика-языка-bequite)
  - [Базовые элементы](#базовые-элементы)
  - [Операторы](#операторы)
  - [Выражения](#выражения)
- [Типы данных](#типы-данных)
  - [Базовые типы](#базовые-типы)
  - [Составные типы](#составные-типы)
  - [Особенности системы типов](#особенности-системы-типов)
- [Операторы и выражения](#операторы-и-выражения-1)
  - [Арифметические операторы](#арифметические-операторы)
  - [Операторы сравнения](#операторы-сравнения)
  - [Логические операторы](#логические-операторы)
  - [Операторы присваивания](#операторы-присваивания)
- [Управляющие конструкции](#управляющие-конструкции)
  - [Условный оператор if-else](#условный-оператор-if-else)
  - [Цикл while](#цикл-while)
  - [Цикл for](#цикл-for)
- [Функции](#функции)
  - [Объявление функций](#объявление-функций)
  - [Параметры функций](#параметры-функций)
  - [Возвращаемые значения](#возвращаемые-значения)
- [Ввод и вывод](#ввод-и-вывод)
  - [Функция input](#функция-input)
  - [Функция output](#функция-output)
- [Работа с массивами](#работа-с-массивами)
  - [Объявление и инициализация](#объявление-и-инициализация)
  - [Доступ к элементам](#доступ-к-элементам)
  - [Функция size](#функция-size)
- [Примеры программ](#примеры-программ)
  - [Пример 1: Быстрое возведение в степень](#пример-1-быстрое-возведение-в-степень)
  - [Пример 2: Бинпоиск](#пример-2-бинпоиск)
  - [Пример 3: Алгоритм Бойера-Мура по поиску подстроки в строке, размером до 50](#пример-3-алгоритм-бойера-мура-по-поиску-подстроки-в-строке-размером-до-50)
- [Приложение: Таблица токенов](#приложение-таблица-токенов)
  - [Ключевые слова](#ключевые-слова)
  - [Операторы](#операторы-1)
  - [Знаки пунктуации](#знаки-пунктуации)

## Введение

### Назначение транслятора BeQuite
Транслятор BeQuite представляет собой программную систему для обработки исходного кода на языке программирования BeQuite. Система выполняет полный цикл трансляции: от лексического анализа до интерпретации программы. Основные функции системы включают:
- Лексический анализ исходного кода
- Синтаксический разбор с построением дерева разбора
- Семантический анализ и проверка типов
- Генерация промежуточного кода (POLIZ)
- Интерпретация промежуточного кода

## Архитектура транслятора

Транслятор BeQuite построен по модульной архитектуре, состоящей из следующих основных компонентов:

### Лексический анализатор (Lexer)
Лексический анализатор выполняет разбор исходного кода на лексемы (токены). Основные функции:
- Чтение исходного файла
- Распознавание ключевых слов с использованием Бора(Trie)
- Классификация лексем на следующие типы:
  - Ключевые слова (Keyword)
  - Идентификаторы (Identificator)
  - Литералы (Literal)
  - Операции (Operation)
  - Знаки пунктуации (Punctuation)

### Синтаксический анализатор (Syntaxer)
Проверяет соответствие потока лексем грамматическим правилам языка BeQuite:
- Рекурсивный спуск по грамматике языка
- Построение абстрактного синтаксического дерева
- Проверка корректности вложенности конструкций

#### Обработка ошибок
Транслятор обнаруживает следующие синтаксические ошибки:
- Несоответствие грамматике языка
- Отсутствие обязательных символов (точки с запятой, скобок)
- Неправильное использование ключевых слов

### Семантический анализатор
Семантический анализатор выполняет проверку смысловой корректности программы. Включает следующие компоненты:

#### Таблица символов (TID)
Древовидная структура для хранения информации об идентификаторах:
- Поддержка вложенных областей видимости
- Хранение информации о типе, размерности и значении переменных
- Проверка уникальности идентификаторов в пределах области видимости

#### Таблица функций (TF)
Структура для хранения информации о функциях:
- Хранение функций (имя, тип возвращаемого значения, параметры)
- Проверка корректности вызовов функций
- Разрешение перегрузки функций

#### Система типов
Механизм проверки совместимости типов в операциях:
- Поддержка базовых типов: int, float, char
- Поддержка массивов с произвольной размерностью
- Автоматическое приведение типов в арифметических операциях
- Проверка типов в операциях присваивания и сравнения

#### Обработка ошибок
Семантический анализатор обнаруживает следующие ошибки:
- Необъявленные идентификаторы
- Несоответствие типов в операциях
- Неправильное количество аргументов при вызове функции
- Повторное объявление идентификатора в той же области видимости
- Использование переменной без инициализации

### Промежуточное представление (POLIZ)

#### Структура POLIZ
Промежуточное представление программы в форме обратной польской записи, используемое транслятором для упрощения последующей интерпретации. Основные особенности:
- **Линейное представление**: Программа представляется в виде линейной последовательности команд
- **Стековая модель**: Вычисления выполняются с использованием стека операндов
- **Отсутствие скобок**: Порядок выполнения операций определяется позицией операторов
- **Управляющие конструкции**: Условные переходы и циклы реализуются через метки и команды переходов

#### Класс Poliz
Основной класс для работы с промежуточным представлением:

```cpp
class Poliz {
public:
    // Add new element to POLIZ
    void push_poliz(poliz_elem lex);
    
    // Create empty slot (placeholder) for later filling
    int blank();
    
    // Get current global pointer position
    int get_gpt();
    
    // Fill previously created blank slot with address
    void push_address(int p);
    
    // Get value at specified position
    string get_value(int p);
    
    // Get type at specified position
    PolizType get_type(int p);
    
    // Print entire POLIZ for debugging
    void print_poliz();
    
    // Get size of POLIZ
    int size();
    
private:
    vector<poliz_elem> p_;  // Vector with POLIZ elements
    int gpt_ = 0;           // Global pointer to next free position
};
```

#### Добавление элементов
Метод `push_poliz()` добавляет новый элемент в конец POLIZ:

```cpp
void Poliz::push_poliz(poliz_elem lex) {
    p_.push_back(lex);  // Add element to vector
    ++gpt_;             // Increment global pointer
}
```

#### Создание заполнителей
Метод `blank()` создает пустой слот для последующего заполнения адресом перехода:

```cpp
int Poliz::blank() {
    p_.push_back({PolizType::LITERAL, ""});  // Create empty literal slot
    return gpt_++;                           // Return current position and increment
}
```

#### Заполнение адресов переходов
Метод `push_address()` заполняет ранее созданный пустой слот адресом перехода:

```cpp
void Poliz::push_address(int p) {
    p_[p].n_ = std::to_string(gpt_);  // Convert current position to string
}
```

#### Управляющие команды (COMMAND)
- `CREATE_TID` — создать новую таблицу символов
- `DELETE_TID` — удалить таблицу символов
- `F!` — условный переход (если false)
- `!` — безусловный переход
- `return` — возврат из функции
- `CALL` — вызов функции
- `INIT` — инициализация переменной
- `BEGIN_LIST` — начало списка инициализации массива
- `END_LIST` — конец списка инициализации массива

### Интерпретатор

#### Архитектура интерпретатора
Интерпретатор выполняет выполнение промежуточного кода POLIZ:

```cpp
class Interpreter {
public:
    Interpreter(Poliz& p, tf& tf);  // Constructor
    void runtime();                 // Main execution method
    
private:
    tf& tf_;                        // Function table
    Poliz& poliz_;                  // Intermediate code (POLIZ)
    int gpt_;                       // Global pointer to commands
    tree_tid global_tid;            // Global symbol table
    std::stack<Call> stack_call;    // Function call stack
    std::stack<std::string> opers_; // Operand stack
};
```

#### Структура Call
Для управления вызовами функций используется структура Call:

```cpp
struct Call {
    tree_tid tid_;   // Local symbol table of the function
    typefunc t_;     // Return type
    int point;       // Return address in POLIZ
};
```

#### Обработка ошибок времени выполнения
- Выход за границы массива
- Деление на ноль
- Обращение к неинициализированной переменной
- Неправильный формат входных данных

## Грамматика языка BeQuite

### Базовые элементы
```
Программа ::= {Объявление}
Объявление ::= ОбъявлениеПеременной ';' | ОбъявлениеФункции ';'
ОбъявлениеПеременной ::= Тип Идентификатор ['=' Выражение] {',' Идентификатор ['=' Выражение]} ';'
ОбъявлениеФункции ::= 'def' ТипФункции Идентификатор '(' [Параметры] ')' '{' {Оператор} '}'
Тип ::= 'int' | 'float' | 'char' | 'let' | 'massive' '<' Тип '>'
ТипФункции ::= Тип | 'void'
Параметры ::= Тип Идентификатор {',' Тип Идентификатор}
```

### Операторы
```
Оператор ::= Выражение ';'
           | ОбъявлениеПеременной ';'
           | УсловныйОператор ';'
           | ЦиклWhile ';'
           | ЦиклFor ';'
           | ВводВывод ';'
           | Возврат ';'
УсловныйОператор ::= 'if' '(' Выражение ')' '{' {Оператор} '}' ['else' '{' {Оператор} '}']
ЦиклWhile ::= 'while' '(' Выражение ')' '{' {Оператор} '}'
ЦиклFor ::= 'for' '(' [Инициализация] ';' [Условие] ';' [Итерация] ')' '{' {Оператор} '}'
ВводВывод ::= 'input' '(' Идентификатор ')'
            | 'output' '(' Выражение ')'
Возврат ::= 'return' [Выражение]
```

### Выражения
```
Выражение ::= E1 {',' E1}
E1 ::= E2 {('=' | '+=' | '-=' | '*=' | '/=' | '%=') E2}
E2 ::= E3 {'or' E3}
E3 ::= E4 {'and' E4}
E4 ::= E5 {('<' | '>' | '<=' | '>=' | '==' | '!=') E5}
E5 ::= E6 {('+' | '-') E6}
E6 ::= E7 {('*' | '/' | '%') E7}
E7 ::= ['!' | 'not' | '-'] E8
E8 ::= '(' Выражение ')'
      | '{' [СписокВыражений] '}'
      | 'size' '(' Идентификатор ')'
      | Идентификатор ['(' [СписокАргументов] ')'] {'[' Выражение ']'}
      | Литерал
СписокВыражений ::= Выражение {',' Выражение}
СписокАргументов ::= Выражение {',' Выражение}
```

## Типы данных

### Базовые типы
Язык поддерживает следующие базовые типы данных:

#### Целочисленный тип (int)
- Диапазон значений: определяемый реализацией

#### Вещественный тип (float)
- Числа с плавающей точкой одинарной точности

#### Символьный тип (char)
- Единичные символы в одинарных кавычках

#### Автоматический вывод типа (let)
- Тип переменной выводится компилятором из инициализирующего выражения
- Обязательная инициализация при объявлении

### Составные типы

#### Массивы (massive)
Массивы представляют собой упорядоченные последовательности элементов одного типа:

```bequite
massive<int> arr1 = {1, 2, 3, 4, 5};
```

### Особенности системы типов

#### Автоматическое приведение типов
Система поддерживает следующие автоматические преобразования в арифметических операциях и присваивании:
- `int` → `float`
- `char` → `int`
- `int` → `char`

#### Проверка совместимости типов
- Операции сравнения разрешены между совместимыми типами
- Присваивание требует точного соответствия типов или допустимого приведения
- Операции индексации применяются только к массивам

## Операторы и выражения

### Арифметические операторы
| Оператор | Описание | Пример |
|----------|----------|--------|
| `+` | Сложение | `a + b` |
| `-` | Вычитание | `a - b` |
| `*` | Умножение | `a * b` |
| `/` | Деление | `a / b` |
| `%` | Остаток от деления | `a % b` |

### Операторы сравнения
| Оператор | Описание | Пример |
|----------|----------|--------|
| `==` | Равенство | `a == b` |
| `!=` | Неравенство | `a != b` |
| `<` | Меньше | `a < b` |
| `>` | Больше | `a > b` |
| `<=` | Меньше или равно | `a <= b` |
| `>=` | Больше или равно | `a >= b` |

### Логические операторы
| Оператор | Описание | Пример |
|----------|----------|--------|
| `and` | Логическое И | `a and b` |
| `or` | Логическое ИЛИ | `a or b` |
| `!` | Логическое НЕ | `!a` |
| `not` | Логическое НЕ | `not a` |

### Операторы присваивания
| Оператор | Описание | Пример |
|----------|----------|--------|
| `=` | Простое присваивание | `a = b` |
| `+=` | Сложение с присваиванием | `a += b` |
| `-=` | Вычитание с присваиванием | `a -= b` |
| `*=` | Умножение с присваиванием | `a *= b` |
| `/=` | Деление с присваиванием | `a /= b` |
| `%=` | Остаток с присваиванием | `a %= b` |

## Управляющие конструкции

### Условный оператор if-else
```bequite
if (expression) {
    // code block if condition is true
} else {
    // code block if condition is false
};
```

### Цикл while
```bequite
while (expression) {
    // code block executed while condition is true
};
```

### Цикл for
```bequite
for (initialization; condition; iteration) {
    // code block executed on each iteration
};
```

## Функции

### Объявление функций
```bequite
def type function_name(parameter1, parameter2, ...) {
    // function body
    return expression;
};
```

### Параметры функций
- Параметры передаются по значению
- Поддерживаются параметры базовых типов и массивов
- Не поддерживается тип обьявляемого параметра `let`

### Возвращаемые значения
- Функция может возвращать значение любого типа
- Функции с типом `void` не возвращают значения
- Оператор `return` обязателен

## Ввод и вывод

### Функция input
Функция `input` считывает значение:

```bequite
int x;
input(x);  // reads integer value into variable x
```

### Функция output
Функция `output` выводит значение:

```bequite
output(42);           // outputs number 42

output('H');      
output('e');
output('l');
output('l');
output('o');    // outputs "Hello"

output(x + y);        // outputs result of expression
```

## Работа с массивами

### Объявление и инициализация
```bequite
massive<int> arr1 = {1, 2, 3, 4, 5};
massive<float> arr2 = {1.0, 2.5, 3.7};
massive<char> str = {'H', 'e', 'l', 'l', 'o'};
```

### Доступ к элементам
```bequite
massive<int> arr = {1, 2, 3, 4, 5};
int first = arr[0];    // access first element
arr[2] = 10;           // modify third element
```

### Функция size
Функция `size` возвращает размер массива:

```bequite
massive<int> arr = {1, 2, 3, 4, 5};
int length = size(arr);  // length = 5
```

## Примеры программ

### Пример 1: Быстрое возведение в степень
```bequite
def float fast_pow(int n, int a) {
    if (a == 0) {
        return 1.0;
    };
    if (a < 0) {
        return 1.0 / fast_pow(n, -1 * a);
    } else {
        if (a % 2 == 0) {
            float tmp = fast_pow(n, a / 2);
            return tmp * tmp;
        } else {
            return a * fast_pow(n, a - 1);
        };
    };
    return -1.0;
};
```

### Пример 2: Бинпоиск
```bequite
def int binary_search(int l, int r, int tar, massive<int> a) {
    int mid;
    while (l + 1 < r) {
        mid = l + (r - l) / 2;
        if (a[mid] > tar) {
            r = mid;
        } else {
            l = mid;
        };
    };
    return l;
};
```

### Пример 3: Алгоритм Бойера-Мура по поиску подстроки в строке, размером до 50
```bequite
def massive<int> build_bad_char_table(massive<char> pattern) {
    int pattern_len = size(pattern);
    massive<int> bad_char = {pattern_len, pattern_len, pattern_len, pattern_len, pattern_len,
                             pattern_len, pattern_len, pattern_len, pattern_len, pattern_len,
                             pattern_len, pattern_len, pattern_len, pattern_len, pattern_len,
                             pattern_len, pattern_len, pattern_len, pattern_len, pattern_len,
                             pattern_len, pattern_len, pattern_len, pattern_len, pattern_len,
                             pattern_len};
    
    for (int i = 0; i < pattern_len - 1; i = i + 1) {
        int index = pattern[i] - 'a';
        if (index >= 0 and index < 26) {
            bad_char[index] = pattern_len - 1 - i;
        };
    };
    
    return bad_char;
};

def massive<int> build_good_suffix_table(massive<char> pattern) {
    int pattern_len = size(pattern);
    
    massive<int> good_suffix = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                                0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                                0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                                0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                                0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    
    if (pattern_len > 50) {
        return good_suffix;
    };
    
    for (int i = 0; i < pattern_len; i = i + 1) {
        good_suffix[i] = pattern_len;
    };
    
    for (int i = 1; i < pattern_len; i = i + 1) {
        int j = 0;
        while (j < pattern_len - i and pattern[j] == pattern[i + j]) {
            j = j + 1;
        };
        if (j == pattern_len - i) {
            if (pattern_len - i - 1 >= 0) {
                good_suffix[pattern_len - i - 1] = i;
            };
        };
    };
    
    if (pattern_len - 1 >= 0) {
        good_suffix[pattern_len - 1] = 1;
    };
    
    return good_suffix;
};

def int boyer_moore_search(massive<char> text, massive<char> pattern) {
    int text_len = size(text);
    int pattern_len = size(pattern);

    if (pattern_len == 0) {
        return 0;
    };
    if (pattern_len > text_len) {
        return -1;
    };
    if (pattern_len > 50) {
        return -1; 
    };
    
    massive<int> bad_char = build_bad_char_table(pattern);
    massive<int> good_suffix = build_good_suffix_table(pattern);
    
    int i = 0;
    while (i <= text_len - pattern_len) {
        int j = pattern_len - 1;
        
        while (j >= 0 and pattern[j] == text[i + j]) {
            j = j - 1;
        };
        
        if (j < 0) {
            return i;
        } else {
            int char_idx = text[i + j] - 'a';
            int shift1 = pattern_len;
            
            if (char_idx >= 0 and char_idx < 26) {
                shift1 = bad_char[char_idx] - (pattern_len - 1 - j);
            };
            
            int shift2 = 0;
            if (j >= 0 and j < pattern_len) {
                shift2 = good_suffix[j];
            };
            
            int shift = shift1;
            if (shift2 > shift1) {
                shift = shift2;
            };
            
            if (shift <= 0) {
                shift = 1;
            };
            
            i = i + shift;
        };
    };
    return -1;
};
```

## Приложение: Таблица токенов

### Ключевые слова
| Токен | Описание |
|-------|----------|
| `def` | Объявление функции |
| `int` | Целочисленный тип |
| `float` | Вещественный тип |
| `char` | Символьный тип |
| `let` | Автоматический вывод типа |
| `massive` | Тип массива |
| `void` | Тип без значения |
| `if` | Условный оператор |
| `else` | Альтернативная ветка условия |
| `while` | Цикл while |
| `for` | Цикл for |
| `return` | Возврат из функции |
| `input` | Ввод данных |
| `output` | Вывод данных |
| `size` | Получение размера массива |
| `true` | Логическая истина |
| `false` | Логическая ложь |

### Операторы
| Токен | Описание |
|-------|----------|
| `+` | Сложение |
| `-` | Вычитание |
| `*` | Умножение |
| `/` | Деление |
| `%` | Остаток от деления |
| `=` | Присваивание |
| `+=` | Сложение с присваиванием |
| `-=` | Вычитание с присваиванием |
| `*=` | Умножение с присваиванием |
| `/=` | Деление с присваиванием |
| `%=` | Остаток с присваиванием |
| `==` | Равенство |
| `!=` | Неравенство |
| `<` | Меньше |
| `>` | Больше |
| `<=` | Меньше или равно |
| `>=` | Больше или равно |
| `and` | Логическое И |
| `or` | Логическое ИЛИ |
| `!` | Логическое НЕ |
| `not` | Логическое НЕ (альтернатива) |

### Знаки пунктуации
| Токен | Описание |
|-------|----------|
| `;` | Конец оператора |
| `,` | Разделитель |
| `(` | Открывающая круглая скобка |
| `)` | Закрывающая круглая скобка |
| `{` | Открывающая фигурная скобка |
| `}` | Закрывающая фигурная скобка |
| `[` | Открывающая квадратная скобка |
| `]` | Закрывающая квадратная скобка |
| `<` | Открывающая угловая скобка |
| `>` | Закрывающая угловая скобка |
